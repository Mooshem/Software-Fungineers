===================================================================
TEAM INFORMATION
===================================================================

    //////////////////
    Team Members
    \\\\\\\\\\\\\\\\\\

        Donovan Thach - Project Manager
        Zheng Chen    - UX / Design Lead and Quality Assurance
        Cash Limberg  - Lead Developer
        Daniel Martin - Educational Game Design Lead

    //////////////////
    Team Artifacts
    \\\\\\\\\\\\\\\\\\

        GitHub: Software-Fungineers
        https://github.com/Mooshem/Software-Fungineers

    //////////////////
    Team Communication
    \\\\\\\\\\\\\\\\\\

        Discord

===================================================================
Project Description
===================================================================   

    //////////////////
    Abstract
    \\\\\\\\\\\\\\\\\\

        Our team is developing a 3D game simulation for visualizing and practicing
        coding. We will create a 3D space for users to learn the fundamentals to 
        programming, using blocks and lines as functions and commands. This will 
        allow a generation that grew up playing videogames to learn how to 
        program in an environment that they are familiar with.

    //////////////////
    Goal
    \\\\\\\\\\\\\\\\\\

        The problem that our team is solving is teaching new users how to program. Our
        unique way of solving this problem is relating these users towards something that
        they are familiar with; video games. 

    //////////////////
    Current Practice
    \\\\\\\\\\\\\\\\\\

        There are two main ways that this problem is solved currently. Firstly, coding games like
        Coddy where the aim is to teach specific syntax of languages in a game format. Secondly,
        other 2d block coding platforms like Scratch that have less emphasis on the 'game' aspect,
        and more on a creative sandbox or tool for developers.

    //////////////////
    Novelty
    \\\\\\\\\\\\\\\\\\

        The novelty of our project comes from the 3d space that users will interact with and the
        puzzles that will be specifically designed for beginners who have never coded before.
        Coding games like Coddy usually specify a syntax (i.e. Java or C), but our project uses block
        coding to avoid the problem of beginners simply memorizing syntax. Taking inspiration from
        Scratch as a block coding tool, we will implement our project in 3d which adds another level
        of interactivity and visualization. This is ideal because we want our users to see their
        code working in real time step by step rather than staring at lines of code.

    //////////////////
    Effects
    \\\\\\\\\\\\\\\\\\

        Beginners to programming would find it useful to visualize what is actually 
        happening with their code. The majority of our team works as TA’s, and we’ve 
        noticed a gap in fundamental knowledge that we believe visualization can help 
        bridge.

    //////////////////
    Use Cases
    \\\\\\\\\\\\\\\\\\

######################################
    Daniel Martin - Use Case: Sandbox Mode

        As a user, I want to be able to experiment with combinations 
        of blocks not taught by the tutorial/puzzles so that I can 
        further understand the way different pieces of code interact.
        
        Actors: User, System
        Triggers: User has completed all puzzles and is left with unanswered questions or curious about other interactions
        Preconditions: 
            - User has completed all puzzles
            - User has navigated to and opened the sandbox mode
                    
        Postconditions (success scenario): 
            - System stores sandbox data for user to come back to
            - System handles wide variety of block interactions
            - User can develop and visualize a wide variety of 
              potential programs, beyond what the tutorial and 
              puzzles offer.
        
        List of steps (success scenario):
            - User completes all puzzles
            - User navigates to Sandbox mode
            - User places up to 25 blocks, and views working interactions
            - User leaves sandbox mode
                    
        Exceptions: failure conditions and scenarios: 
            - Block interactions are not robust: Placing in unplanned ways leads to bugs.
            - Placing too many blocks stresses resources too highly, program crashes.

######################################

        CL - A user wants to get into programming, but they are unsure where to start. They will
             use our game to learn how programming language fundamentals function.

            Actor: Cranjis McBasketball
            Triggers: Mr McBasketball doesn't know where to start learning programming, and wants 
                      to start somewhere that isn't overwhelming.
            Preconditions: 
                - Mr McBasketball has a need for learning programming
            Postconditions (success scenario): 
                - Mr McBasketball successfully learns the fundamentals of programming so he can
                  apply it to a language of his choice
                - Mr McBasketball successfully completes the puzzles offered in the game
            List of steps (success scenario): 
                1. Mr McBasketball opens the game
                2. Mr McBasketball completes puzzle 1
                3. Mr McBasketball completes puzzle 2
                4. Mr McBasketball completes puzzle 3
            Extensions/variations of the success scenario:
                - Mr McBasketball already understands functions, so he stops at puzzle 2
                - Mr McBasketball replays a puzzle that he thinks he could solve better
            Exceptions: failure conditions and scenarios: 
                - Mr McBasketball does not complete puzzle 1, which doesn't allow him to 
                  continue to puzzle 2

######################################

        Zheng Chen - Use Case: Code Visualization for Debugging
    
            As a user, I want to visualize how my code executes step-by-step 
            so that I can understand why my programs don't produce expected 
            results and learn to debug effectively.
            
            Actors: User, System
            Triggers: User writes code that compiles but doesn't work as expected, leading to frustration with traditional debugging methods
            Preconditions: 
                - User has basic knowledge of programming syntax like variables
                - User has the game installed and accessible
                - User has completed introductory tutorial
                        
            Postconditions (success scenario): 
                - User successfully visualizes how loops and conditionals execute step by step
                - User understands why their previous code didn't work as expected
                - User can apply visualization knowledge to debug real code
                - System saves user's puzzle progress
            
            List of steps (success scenario):
                - User opens the game and selects a "Loop Visualization" puzzle
                - User places blocks to build a for-loop structure
                - User connects conditional blocks within the loop
                - User runs the visualization and watches 3D execution
                - User observes how the loop counter changes and how conditionals affect flow
                - User pauses execution at key points to examine block states
                - User completes the puzzle
            
            Extensions/variations of the success scenario:
                - User replays visualization at different speeds
                - User modifies puzzle parameters to test edge cases
                - User applies knowledge to fix bugs in actual code
                        
            Exceptions: failure conditions and scenarios: 
                - User can't understand the block metaphor and needs additional tutorial
                - Visualization speed cannot be adjusted properly, hindering comprehension
                - User's computer doesn't meet minimum requirements, causing lag

######################################

        Donovan Thach - Use Case: Preferred Learning

        As a user, I want a simpler more engaging way to learn
        how to program, like playing a game, so I can more easily
        understand the fundamentals.

            Actors: User, System
            Triggers: User doesn't engage well with content that includes sitting and learning, they prefer interactions and games
            Preconditions: 
                - User wants to interact and engage with programming
                - User is familar with a 3D environment in games
                - User wants to learn the fundamentals of coding
            Postconditions (success scenario): 
                - User spends less than 3 minutes to learn a fundamental of programming
                - System contains tutorial level showing user how to play the game and
                  assists in early learning of assigning values to variables
            List of steps (success scenario): 
                1. User downloads the game off of a website
                2. User opens our software and enters the tutorial level
                3. User completes the tutorial level in under 3 minutes
            Extensions/variations of the success scenario: 
                - User goes past the tutorial and continues through the game and playing 
                  different puzzles
                - If the User forgets about the tutorial, they can always replay it again
                - User can decide to skip the tutorial if they deem it unnecessary
            Exceptions: failure conditions and scenarios: 
                - User can't complete the tutorial due to the difficulty and decides to 
                  give up on the game
                - User spends more than 3 minutes on tutorial, meaning it's still too
                  difficult to be learned by a novice programmer
                - Tutorial level is stuck on the success screen; never allows user to 
                  pass the tutorial, locking access to the game

######################################

    //////////////////
    Non-Functional Requirements
    \\\\\\\\\\\\\\\\\\

        The program will run without lagging, creating a seamless user experience.

        The program will start within 3 seconds of running the program.

        The program will be able to support 1 user.

        New users must be able to complete the first puzzle within 10 minutes.

        Must run on integrated graphics cards.

    //////////////////
    External Requirements
    \\\\\\\\\\\\\\\\\\

        The application will be downloaded through an external website, and the application will be ran on
        a Windows OS, on Windows 10/11, or alternatively a Linus or MacOS system. 4GB Ram required, and a
        minimum of at least an integrated graphics card.

        All third-party libraries and 3D graphics frameworks used must have permissive open-source 
        licenses (MIT, Apache 2.0, or similar) to allow free distribution to educational institutions
        
        The programming concepts taught (variables, conditionals, loops, functions) must align with standard 
        CS curriculum frameworks

    //////////////////
    Technical Approach
    \\\\\\\\\\\\\\\\\\

        We have decided to go with an event-driven architecture as it lends itself well to Godot's built-in
        signal system. We will have player actions (such as walking, placing a block, etc.) act as events
        that drive the rest of the program. To solve the initial problem of teaching absolute beginners the
        fundamentals of programming, we wwill not be teaching any language in particular. Instead, we plan on
        implementing a 'block code' language where conditions, variables, and other pieces of a program will be
        implemented as physical blocks that the user can place and manipulate. The reason why this approach
        is ideal is that users will be able to interact with their code more freely. We plan on implementing a
        signal system where signals will travel through wires, and users can physically see the control flow
        of their program. The block code style has worked successfully in the past with projects like Scratch,
        but we believe a 3d environment will make it even easier to understand for complete beginners. Our team
        is mostly composed of ULAs for intro programming courses, so to make sure the content is educational, we
        will work together and agree upon which content to add or remove from in-game puzzles to challenge the
        user at an appropriate level. We will use the Godot game engine to implement our game.

    //////////////////
    Risks
    \\\\\\\\\\\\\\\\\\

    1) Late implementation. LIkelihood: medium Risk: high. As of now, we haven't spent enough 
       time implementing. This has a high impact because our game will be unfinished. My evidence
       is as follows: so far, we have yet to fully implement any of our classes. Now, we are 
       pushing to get our ideas implemented, in order to prevent the likelihood of this occurring.
       We will implement the basic game flow within the next week to build a foundation. The
       problem has taken effect if we don't have this done. We will take these steps in that case: 
       Designate each person to fully implement a feature by the end of the week. This will give us
       at least 4 features built, and we will need to continue this trajectory to stay on track.

    2) Block placing logic harder than expected. Likelihood: medium, Impact: high. This part of
       the code is likely to be hard to implement. As an integral part to the game, it would have
       a huge impact if left unchecked. To reduce likelihood, we have started watching godot tutorials
       and have compiled a list of a few videos that can help. Detecting the problem will be simple
       because whoever is implementing this part of the code at the time will communicate. We've
       all agreed to communicate issues as important as this. Should this risk occur, we will
       research the necessary implementation details and work on the implementation together. This 
       risk will be identified soon, as we plan on implementing this in the coming weeks.

    3) Blocks don't work properly. Likelihood: High, Impact: High. The blocks are going to take a
       lot of work to properly implement, and we need them to work flawlessly if we want to teach
       beginners. The chance of them not working properly at first is almost guaranteed, so it is
       imperative to plan ahead. To reduce the likelihood, we will have to make sure each block
       follows the guidelines that we've layed out prior. Right now, we have a list of required
       blocks and how they should behave, so we will follow this guide, and test them after
       implementation. To detect the problem, we will run tests on each block. We will do this by
       placing them next to other ones and observing their behavior, and by using our test plan
       below. Should this occur, we plan on following standard debugging procedure for broken blocks,
       and making sure they behave as required (outlined below).

    4) Godot 3D mechanics and engine limitations slow progress. Likelihood: medium, Impact: medium-high.
       None of us have extensive experience building a full 3D game with Godot. While we are confident
       we can learn, unexpected engine limitations or confusing workflows could slow development. This
       could impact our timeline and force us to spend time debugging engine-related issues rather than
       implementing. Evidece: so far, some basic tasks (such as scene organization) have taken longer
       than expected during experimentation. To reduce the likelihood of this occurring, we are keeping 
       our game mechanics simple and relying on Godot’s built-in systems whenever possible rather than 
       creating overly complex custom solutions. We are also sharing resources and tutorials within 
       the team. We will detect this problem if tasks involving Godot repeatedly fall behind schedule or 
       require excessive troubleshooting. If this risk occurs, we will mitigate it by cutting 
       non-essential features and refocusing on core gameplay and learning objectives.

    5) Educational goals are not clearly achieved through gameplay. Likelihood: medium, Impact: medium-high.
       It's possible that the game does not clearly teach introductory programming concepts as intended.
       Our evidence for this risk comes from early discussions where some mechanics felt engaging but did
       not clearly reinforce learning objectives. To reduce the likelihood of this occurring, we are explicitly
       tying each block and level to a specific programming concept and designing levels around 
       those goals. We also plan to add clear visual feedback so players can see the effect of their 
       blocks in real time. We will detect this issue through playtesting, especially by observing whether 
       new players can explain what their block logic is doing. If this risk occurs, we will 
       mitigate it by redesigning levels, adding tutorials or guided prompts, and simplifying 
       mechanics to better emphasize learning outcomes.

    //////////////////
    Timeline
    \\\\\\\\\\\\\\\\\\

        Week 6
            Implement blocks -- placing and interactions with player -- as well as a functional 'Home Screen' UI

        Week 7
            Add level assets and textures as well as sound effects; Fully implement blocks

        Week 8
            Polish the UI, debug block interactions, run through levels to ensure nothing is too hard. Perform unit
            tests on individual classes (blocks) and fuzz the UI interactions

        Week 9
            Continue testing. Non-programmer friends/family playtest our game and give comments. Polish level design,
            sound design, and any other bugs that have popped up.

        Week 10
            Finish tests, documentation, and prepare for final presentation. Prepare a demo video for the first level.

    //////////////////
    Team Process Description
    \\\\\\\\\\\\\\\\\\
    
    Software Toolset:

        Tool: Godot 
        Justification: Open-source 3D game engine with MIT license meeting our external requirements. 
            It also has built-in 3D tools and visual scripting.

        Tool: Visual Studio Code
        Justification: IDE we're familiar with, and has GDScript extensions and version control integration.

        Tool: GitHub
        Justification: Essential for team collaboration. Provides issue tracking and project management tools.

    Team Member Roles:

        Donovan Thach - Project Manager
            Why this role is needed: Big projects with tight deadlines requires someone to ensure that the team
                not only stays on track, but also that the project will be deliverable by the assumed date that
                it is due.
            Why Donovan is suited: Experience with many teams that required leadership or a constant drive.

        Zheng Chen - UX/Design Lead and Quality Assurance
            Why this role is needed: Educational games require intuitive interfaces so users focus on
                learning programming concepts rather than struggling with controls.
            Why Zheng is suited: Experience with TAing reveals and provides direct insight to common student
                struggles with programming concepts.

        Cash Limberg - Lead Developer
            Why this role is needed: We need a lead developer due to the challenge of developing this specific
                game, and the challenges that it poses to work with a group of people. Giving the group a lead 
                developer allows for all the programmers in the group to be directed and understand their  
                job in the team.
            Why Cash is suited: Cash has TAed before, leading a group of people through complex coding problems
                and solutions. Cash has demonstrated that he is capable of understanding others' programs, and 
                quickly diagnosing potential risks that those problems can cause if left untreated.

        Daniel Martin - Game Design Lead
            Why this role is needed: As an educational game, we need to ensure that the content is appropriate.
                This means that the overall game loop must be engaging, but more importantly, it needs to
                actually teach players coding fundamentals. This role ensure that both of those criteria is met.
            Why Daniel is suited: Daniel is a ULA for intro CS classes, and has experience with common pitfalls
                that trap beginner programers. Through this experience, Daniel has learned what students typically
                struggle with and what needs to be emphasized for the game to be educational.

    Weekly Schedule and Milestones

        Week 6:
            Donovan: Resolve any complications that resulted from the week prior and work with team members to continue
                        progress.
            Zheng: Block placement UI functional - visual feedback for valid/invalid placement working.
            Cash: Develop Block placement, and have user movement and block placing completed. Draft block implementations.
            Daniel: Plan levels that follow curriculum plan and are an appropriate challenge level

        Week 7:
            Donovan: Overall QA meeting 1, collect and create a checklist for any bugs found.
            Zheng: QA testing complete for puzzle 1. Bug list documented with priorities assigned.
            Cash: Block implementation should be finalized. Begin the development of the puzzles. 
            Daniel: Implement levels to the game and have other team members play test to make sure they are the right difficulty

         Week 8:
            Donovan: Ensure members with bugs aligning to their roles have been resolved and ensure project scope will
                        be within the deadline.
            Zheng: UI polish and refinements based on Week 6 playtest feedback. All visual elements finalized.
            Cash: Ensure all code is working seamlessly. Fix potential bug problems and ensure that all test cases
                        and use cases are passed. Work on tutorial system.
            Daniel: Implement a sandbox mode with infinite block placement, and handle any edge cases not found in predefined puzzles.

        Week 9:
            Donovan: Confirm that the scope is maintained again, finalize ideas and full scope, continue working with
                        lead developer.
            Zheng: Tutorial system implemented. Help tooltips functional for all block types.
            Cash: Tutorial should be finished. Continue fixing bugs and ensure all test cases and use cases are passed.
            Daniel: Test the puzzles multiple times, have others test them, and continue making more if there's time.

        Week 10:
            Donovan: Overall QA meeting 2, finalize project, ensure all user stories' goals are met, deliver project. 
                        Rid of any other complications in the development process.
            Zheng:  Final QA pass complete and all critical bugs resolved. UX improvements from playtesting implemented.
            Cash: Tie up lose ends, and finalize last resolves. 
            Daniel: Finalize puzzles/levels, look for any last minute exploits that pop up.

    Major Risks:

    1) Late implementation. LIkelihood: medium Risk: high. As of now, we haven't spent enough 
       time implementing. This has a high impact because our game will be unfinished. My evidence
       is as follows: so far, we have yet to fully implement any of our classes. Now, we are 
       pushing to get our ideas implemented, in order to prevent the likelihood of this occurring.
       We will implement the basic game flow within the next week to build a foundation. The
       problem has taken effect if we don't have this done. We will take these steps in that case: 
       Designate each person to fully implement a feature by the end of the week. This will give us
       at least 4 features built, and we will need to continue this trajectory to stay on track.

    2) Block placing logic harder than expected. Likelihood: medium, Impact: high. This part of
       the code is likely to be hard to implement. As an integral part to the game, it would have
       a huge impact if left unchecked. To reduce likelihood, we have started watching godot tutorials
       and have compiled a list of a few videos that can help. Detecting the problem will be simple
       because whoever is implementing this part of the code at the time will communicate. We've
       all agreed to communicate issues as important as this. Should this risk occur, we will
       research the necessary implementation details and work on the implementation together. This 
       risk will be identified soon, as we plan on implementing this in the coming weeks.

    3) Blocks don't work properly. Likelihood: High, Impact: High. The blocks are going to take a
       lot of work to properly implement, and we need them to work flawlessly if we want to teach
       beginners. The chance of them not working properly at first is almost guaranteed, so it is
       imperative to plan ahead. To reduce the likelihood, we will have to make sure each block
       follows the guidelines that we've layed out prior. Right now, we have a list of required
       blocks and how they should behave, so we will follow this guide, and test them after
       implementation. To detect the problem, we will run tests on each block. We will do this by
       placing them next to other ones and observing their behavior, and by using our test plan
       below. Should this occur, we plan on following standard debugging procedure for broken blocks,
       and making sure they behave as required (outlined below).

    4) Godot 3D mechanics and engine limitations slow progress. Likelihood: medium, Impact: medium-high.
       None of us have extensive experience building a full 3D game with Godot. While we are confident
       we can learn, unexpected engine limitations or confusing workflows could slow development. This
       could impact our timeline and force us to spend time debugging engine-related issues rather than
       implementing. Evidece: so far, some basic tasks (such as scene organization) have taken longer
       than expected during experimentation. To reduce the likelihood of this occurring, we are keeping 
       our game mechanics simple and relying on Godot’s built-in systems whenever possible rather than 
       creating overly complex custom solutions. We are also sharing resources and tutorials within 
       the team. We will detect this problem if tasks involving Godot repeatedly fall behind schedule or 
       require excessive troubleshooting. If this risk occurs, we will mitigate it by cutting 
       non-essential features and refocusing on core gameplay and learning objectives.

    5) Educational goals are not clearly achieved through gameplay. Likelihood: medium, Impact: medium-high.
       It's possible that the game does not clearly teach introductory programming concepts as intended.
       Our evidence for this risk comes from early discussions where some mechanics felt engaging but did
       not clearly reinforce learning objectives. To reduce the likelihood of this occurring, we are explicitly
       tying each block and level to a specific programming concept and designing levels around 
       those goals. We also plan to add clear visual feedback so players can see the effect of their 
       blocks in real time. We will detect this issue through playtesting, especially by observing whether 
       new players can explain what their block logic is doing. If this risk occurs, we will 
       mitigate it by redesigning levels, adding tutorials or guided prompts, and simplifying 
       mechanics to better emphasize learning outcomes.


    External Feedback:
        When external feedback will be most useful:
            After first playable prototype is complete (likely in weeks 7-8), early enough to make significant changes
            based on feedback, or Week 8 after all core features implemented
        
        How we will get that feedback:
            Recruit non-programmer friends and family for playtesting, and create feedback forms asking specific questions.

===================================================================
Implementations
===================================================================

    //////////////////
    Major Features
    \\\\\\\\\\\\\\\\\\

        1.  Implement 3D movement from player
        2.  Implement the ability to place/remove blocks
        3.  Implement blocks abilities, such as conditional statements
        4.  Implement the ability to connect blocks for linearly programming
        5.  Implement puzzle levels

    //////////////////
    Stretch Goals
    \\\\\\\\\\\\\\\\\\

        1.  Implement the ability to make functions
        2.  Implement the recursion


===================================================================
Software Architecture
===================================================================

    //////////////////
    Architecture Pattern
    \\\\\\\\\\\\\\\\\\

        Our project uses an event-based architecture in Godot. Systems communicate
        using events rather than direct dependencies, improving modlar design
        and parallel development.

    //////////////////
    Major Components
    \\\\\\\\\\\\\\\\\\

        Gameplay System:
            Executes block logic and validates puzzle solutions.

        UI System:
            Displays menus, feedback, tutorials, and player input.

        Player System:
            Handles movement, camera control, and interactions.

        Puzzle System:
            Loads levels, sandbox mode, and puzzle rules.

        Data System:
            Saves player progress and settings locally.

    //////////////////
    Component Interfaces
    \\\\\\\\\\\\\\\\\\

        UI emits events then Gameplay reacts  
        Gameplay emits events (such as movement or placing blocks) then UI updates  
        Puzzle System emits load events then Game spawns levels  
        Data System listens for save/load events  

    //////////////////
    Data Storage
    \\\\\\\\\\\\\\\\\\

        Player progress and settings stored locally using JSON.
        Puzzle layouts stored as Godot scenes/resources.

    //////////////////
    Assumptions
    \\\\\\\\\\\\\\\\\\

        - Single-player only
        - Windows 10/11 supported
        - No internet required

    //////////////////
    Architecture Decisions
    //////////////////

        Decision 1: Event-Driven vs. Layered Architecture
            Choice: Event-Driven.
            Alternative: Layered Architecture.
            Pros: Layered is highly organized and easy to document.
            Cons: Creates rigid dependencies. Event-driven allows the UI 
                to react asynchronously to gameplay signals, which is 
                more efficient for real-time 3D simulations.

        Decision 2: Event-Driven vs. Microkernel Architecture
            Choice: Event-Driven.
            Alternative: Microkernel Architecture.
            Pros: Microkernel makes every "coding block" a modular plug-in.
            Cons: High initial setup complexity. Event-driven is simpler 
                to implement with Godot’s built-in signal system while 
                maintaining sufficient modularity.

===================================================================
Software Design
===================================================================
    //////////////////
    Component Definitions
    //////////////////
    
        Gameplay System:
            Classes: ExecutionEngine, BlockBase, ActionBlock
            Responsibilities: Interprets block sequences and triggers 3D logic.

        UI System:
            Classes: HUD, MainMenu, BlockInventory
            Responsibilities: Handles menus and the drag-and-drop coding interface.

        Player System:
            Classes: PlayerController, InteractionRaycast
            Responsibilities: Manages 3D movement and block placement targeting.

        Puzzle System:
            Classes: LevelManager, VictoryCondition
            Responsibilities: Loads JSON level data and checks for success states.
       
        Data System:
            Classes: SaveManager, SettingsManager, ProgressTracker
            Responsibilities: Handles saving/loading player progress, puzzle completion data,
            and user settings locally using JSON files.

===================================================================
Coding Guidelines
===================================================================

    //////////////////
    Standards and Enforcement
    //////////////////

        Language: C++
        Link: https://google.github.io/styleguide/cppguide.html

        Justification: 
            Google's C++ style guide is robust and prevents common memory 
            management errors. It ensures our GDExtension code is readable 
            for all team members.

        Enforcement: 
            Mandatory peer review on all GitHub Pull Requests.


===================================================================
Process Description
===================================================================

I) Risk Assessment

    Top 5 risks to successful completion of your project

    1) Late implementation. LIkelihood: medium Risk: high. As of now, we haven't spent enough 
       time implementing. This has a high impact because our game will be unfinished. My evidence
       is as follows: so far, we have yet to fully implement any of our classes. Now, we are 
       pushing to get our ideas implemented, in order to prevent the likelihood of this occurring.
       We will implement the basic game flow within the next week to build a foundation. The
       problem has taken effect if we don't have this done. We will take these steps in that case: 
       Designate each person to fully implement a feature by the end of the week. This will give us
       at least 4 features built, and we will need to continue this trajectory to stay on track.

    2) Block placing logic harder than expected. Likelihood: medium, Impact: high. This part of
       the code is likely to be hard to implement. As an integral part to the game, it would have
       a huge impact if left unchecked. To reduce likelihood, we have started watching godot tutorials
       and have compiled a list of a few videos that can help. Detecting the problem will be simple
       because whoever is implementing this part of the code at the time will communicate. We've
       all agreed to communicate issues as important as this. Should this risk occur, we will
       research the necessary implementation details and work on the implementation together. This 
       risk will be identified soon, as we plan on implementing this in the coming weeks.

    3) Blocks don't work properly. Likelihood: High, Impact: High. The blocks are going to take a
       lot of work to properly implement, and we need them to work flawlessly if we want to teach
       beginners. The chance of them not working properly at first is almost guaranteed, so it is
       imperative to plan ahead. To reduce the likelihood, we will have to make sure each block
       follows the guidelines that we've layed out prior. Right now, we have a list of required
       blocks and how they should behave, so we will follow this guide, and test them after
       implementation. To detect the problem, we will run tests on each block. We will do this by
       placing them next to other ones and observing their behavior, and by using our test plan
       below. Should this occur, we plan on following standard debugging procedure for broken blocks,
       and making sure they behave as required (outlined below).

    4) Godot 3D mechanics and engine limitations slow progress. Likelihood: medium, Impact: medium-high.
       None of us have extensive experience building a full 3D game with Godot. While we are confident
       we can learn, unexpected engine limitations or confusing workflows could slow development. This
       could impact our timeline and force us to spend time debugging engine-related issues rather than
       implementing. Evidece: so far, some basic tasks (such as scene organization) have taken longer
       than expected during experimentation. To reduce the likelihood of this occurring, we are keeping 
       our game mechanics simple and relying on Godot’s built-in systems whenever possible rather than 
       creating overly complex custom solutions. We are also sharing resources and tutorials within 
       the team. We will detect this problem if tasks involving Godot repeatedly fall behind schedule or 
       require excessive troubleshooting. If this risk occurs, we will mitigate it by cutting 
       non-essential features and refocusing on core gameplay and learning objectives.

    5) Educational goals are not clearly achieved through gameplay. Likelihood: medium, Impact: medium-high.
       It's possible that the game does not clearly teach introductory programming concepts as intended.
       Our evidence for this risk comes from early discussions where some mechanics felt engaging but did
       not clearly reinforce learning objectives. To reduce the likelihood of this occurring, we are explicitly
       tying each block and level to a specific programming concept and designing levels around 
       those goals. We also plan to add clear visual feedback so players can see the effect of their 
       blocks in real time. We will detect this issue through playtesting, especially by observing whether 
       new players can explain what their block logic is doing. If this risk occurs, we will 
       mitigate it by redesigning levels, adding tutorials or guided prompts, and simplifying 
       mechanics to better emphasize learning outcomes.


II) Project Schedule

    To begin, templates for a baseplate (map with free-roam), a character (including collision), and a template
    block (also with collision) should be made. The baseplate should be big enough so that the player can move,
    if possible, it should also have invisible boundaries.

    After making templates, our team will move forward in developing the movement for the character, as well as 
    desigining very smooth and efficient animations that won't hinder progress in development. The character's
    model must be finished before this step is complete, otherwise the physics and movement will have to be
    changed. Blocks will be implemented with their own placing mechanics within the game as well. Collision
    must be done first in order to prevent unnecessary rendering bugs or issues. As for the baseplate, a simple
    and light texture should be done on it, and the whole area of the baseplate should have invisible dividers
    should be inplemented to prevent players from placing blocks in between lines for simpler gameplay.

    Once those are implemented, other template blocks should be made with labels, without an explicit function. 
    To add on, afull UI for the player should be made to allow the user to interact with a basic templatized 
    world. At this point the player should be able to do the following:
        1. Move around using WASD keys (standard for most 3D games)
        2. Select certain blocks through a UI system (could be a hotbar or scroll wheel, TBD)
        3. Place down the blocks and have them seen rendered properly
        4. The player won't have to adjust where they want the block, the block will be locked with the grid
        5. The player has other movement capabilities (jumping, crouching, TBD)
        6. Leave the baseplate and enter a new one (for the testing process only)
    During this stage in development, it would be an amazing idea to create some test cases and testing suites
    to ensure that the progress made thus far isn't for nothing. Tests like these will be difficult to create
    as our team plans on using godot, however our team will persevere through that and find some way to test
    eveyrhting mentioned previously.

    Now that a basic UI system has been implemented, our team will then move on towards creating functional
    blocks that the player can interact with. An example follows: 
        For loop block: Possibly have a UI that allows the player to change the index start, index end,
                        and how much it increments by each time.
    Other blocks have yet to be decided, but when set up, they all should have their own test suites and
    fuzzes. This will ensure that the functionality of each block matches the idea we had, and that each
    block will work alongside with other connected blocks.

    One of the most difficult steps after is to start using all the templates our team created to make
    interesting and intriguing puzzles that can be solved by someone new to programming. Tests will be
    even harder to create on this step, which means we'll have to be more cautious when creating the map
    and other functions. Each puzzle should have specified bounds, and creative ideas could be integrated
    into the design if time isn't short. This stage should only be started once all tests have ran 
    successfully and no more bugs have been found. If bugs during an earlier section of the schedule 
    have been rediscovered or discovered in general, all work on current work and work after the
    component that has the bug will be halted, and more tests will be done on the improper component.

    Now that all those have been tested, the puzzles will enter a final testing phase, and after this,
    the stretch goals will be implemented one by one to increase the quality of our product.

    Overall Timeline:
        2026-02-01 - 2026-02-07: Finish architecture and design process, and begin the implementation
                                 phase of development.
        2026-02-08 - 2026-02-14: Use the development cycle of a software to test and evolve the product
                                 through the player animations, hitboxes, and collision aspects. Fully
                                 complete tempaltes for the world and characters.
        2026-02-15 - 2026-02-21: Complete player movement, physics, and block placing. Remake new tests
                                 and using a full coverage to test for small defects in our software.
        2026-02-22 - 2026-02-28: Fully implement in-scope blocks with programming basics (for loops, 
                                 if and else statements, TBD). Continue with testing.
        2026-03-01 - 2026-03-07: Realize scope and create puzzles, the last week will be saved for
                                 the most amount of testing and evolving of the product, as well as
                                 scope changes and solidifying the goal.
        2026-03-08 - 2026-03-14: Once scope is realized, ensure all tests are passed before developing
                                 extra stretch goals to improve the quality of the product.

    Through this schedule, our team will be able to work smoothly and realize our deadlines more easily.

III) Team Structure

    The knowledge on team structure and our team roles are going to stay consistent as they have been
    above this section. See the 'Team Process Description' subtitle of the 'Project Description' for 
    more clarification on what each member does, and their role in the project.

IV) Test Plan & Bugs

    We plan on significantly testing our block code works and our loops work.  To test this, our team is 
    going to devise multiple solutions to each puzzle, and ensure that said solutions achieve the correct 
    result. We also plan on testing edge cases that users could conjure up, such as running permanently 
    iterative or recursive code, and designing a solution to this.

V) Documentation Plan

    Our team plans on delivering documentation for keybinds, a user manual, and an information doc on what
    each block does and what it represents in coding languages, and help text for each puzzle.

===================================================================
Testing Plan
===================================================================

Test-Automation Infrastructure:
    GUT
    https://gut.readthedocs.io

Why GUT?
    GUT (Godot Unit Test) is a widely-used third-party testing plugin for Godot projects. We chose it 
    because it is written in and designed for GDScript, which is the scripting language our project uses. 
    It integrates directly into the Godot editor, supports running tests headlessly from the command line, 
    making CI integration straightforward. It also provides familiar testing conventions like assert_eq, 
    before_each, and after_each that make tests easy to read and write.

How to Add New Test Cases:
    1. Navigate to the tests/ directory in the project root.
    2. Create a new GDScript file with a test_ prefix (e.g., test_player.gd). GUT uses this prefix to 
       automatically discover and run test files.
    3. At the top of the file, add extends GutTest.
    4. Write individual test functions with names beginning with test_ (e.g., func test_player_takes_damage()).
    5. Use GUT's built-in assertion methods such as assert_eq, assert_true, and assert_null to verify 
       expected behavior.
    6. Run your tests either through the GUT panel in the Godot editor, or from the command line using 
       headless mode for CI purposes.
    7. Refer to existing tests in tests/ or the GUT documentation for examples.

CI Service:
    We use GitHub Actions as our CI service. It is configured via two YAML workflow files located in 
    .github/workflows/ in the repository. GitHub Actions accesses the repository automatically since it is 
    a native GitHub feature, requiring no external account linking or webhook setup.

    The first workflow (tests.yml) handles automated testing. The workflow is triggered on:
        - Any push to main or any branch matching feature/**
        - Any pull request targeting main
        - Manual triggers via workflow_dispatch (useful for debugging CI without a commit)

    The build runs on ubuntu-24.04 using the barichello/godot-ci:4.6.1 Docker image, which provides a 
    pre-configured headless Godot environment. The CI pipeline does the following in order:
        1. Checks out the repository (with LFS support for binary assets)
        2. Installs libfontconfig1, a runtime dependency required by Godot in headless mode
        3. Imports project assets and classes so Godot's resource system is initialized
        4. Runs the full GUT test suite headlessly via the command line

    The second workflow (export.yml) handles platform exports and is triggered on pushes to main and manual 
    triggers. It contains two jobs: the Windows export job runs on ubuntu-24.04 using the barichello/godot-ci 
    Docker image to produce a .exe build, and the Mac export job runs on a native macos-latest runner, 
    installing Godot via Homebrew and downloading export templates directly from the Godot releases page. 
    Both jobs upload their builds as artifacts using actions/upload-artifact, making them available for 
    download directly from the GitHub Actions run.

Why GitHub Actions?
    We chose GitHub Actions because it integrates natively with our GitHub repository, requiring no external 
    account setup or webhook configuration. It is free for public repositories, and the workflow 
    configuration lives directly in the repo as versioned .yml files, meaning CI changes are tracked 
    alongside the code. GitHub Actions also has a large marketplace of community actions (such as 
    actions/checkout and actions/upload-artifact) that simplified our setup, and it supports both Docker 
    containers and multiple runner environments. This was particularly important for our project, as we run 
    two separate export workflows: the Windows export uses the barichello/godot-ci Docker image on an Ubuntu 
    runner, while the Mac export runs on a native macos-latest runner and installs Godot via Homebrew to 
    ensure a proper macOS build environment. Both workflows produce uploadable artifacts for their 
    respective platforms.

Which Tests Are Executed in the CI Build?
    All tests following GUT's naming convention, where test files and test functions are both prefixed with 
    test_, will be automatically discovered and executed in the CI build. This includes unit tests, 
    integration tests, validation tests, and system tests. The CI workflow invokes GUT with the 
    -gdir=res://tests and -ginclude_subdirs flags, meaning any test file placed anywhere within the tests/ 
    directory or its subdirectories will be picked up and run automatically without any additional 
    configuration.

Triggers for a CI Build:
    A CI build is triggered by any push to main or any branch matching feature/**, any pull request targeting 
    main, and manual triggers via workflow_dispatch. The export workflow is triggered only on pushes to main 
    and manual triggers, as platform builds are intended to reflect stable, merged code rather than 
    work-in-progress branches.